This page describes how to use Amazon's Route 53 service, a scalable and highly available Domain Name System, domain registration system, and health checking service.<ref>[https://aws.amazon.com/route53/faqs/ Amazon Route 53 FAQs]</ref><ref>[https://en.wikipedia.org/wiki/Amazon_Route_53 Amazon Route 53]</ref> The focus of this page is on the use of Address (A) records and Canonical Name (CNAME) records in Route 53, the significance of Alias Records, as well as the role that health checks and routing policies play.

You can also get basic onboarding and usage instructions on Route 53 from the AWS documentation,<ref>[http://aws.amazon.com/route53/ Amazon Route 53]</ref> external summaries of best practices,<ref>[https://cloudnative.io/blog/2015/03/aws-route-53-best-practices/ AWS Route 53 Best Practices]</ref> and online video and text tutorials.<ref>[https://www.youtube.com/watch?v=qsUKki0TUuc Using the Route 53 Management Console]</ref><ref>[https://www.youtube.com/watch?v=olEz_cTqGWM Setting up AWS Route 53 DNS System]</ref><ref>[http://resources.intenseschool.com/amazon-aws-understanding-route-53-part-ii/ Amazon AWS – Understanding Route 53 – Part II]</ref>
[[Category:Computers and Electronics]]
[[Category:Articles in Quality Review]]

== Steps ==

=== Understanding what Route 53 is for ===

# Route 53 helps clients resolve DNS requests for your domain or subdomain.
#* Route 53 can be used as an authoritative DNS for your domains and subdomains. This means that anybody who wants to look up your domain must get it from Route 53 either directly or indirectly.
#* The IP address that Route 53 returns for a domain to a client is computed based on the client's IP address and the Route 53 record sets and policies configured by you.
#* The routing policy used by Route 53 can take into account the health of the endpoints in various ways (TCP health checks, HTTP status endpoint health checks with string matching).
#* Route 53 follows a "principle of constant work": the amount of work done by Route 53 is independent of the health of the endpoints being checked. This is to avoid the problem of "cascading failures" introduced by Route 53 actions. This does not preclude the possibility of Route 53 health checks indirectly leading to cascading failures due to traffic redirection; however, Route 53 itself remains robust.<ref>[http://www.awsarchitectureblog.com/2014/06/constant-work.html Doing Constant Work to Avoid Failures]</ref>
#* Route 53 record sets have their own Time To Live (TTL) that can be set to 60 seconds or more. Any client or intermediate DNS resolver is supposed to respect this TTL: if it has not refreshed the resolution of the domain or subdomain for the duration of the TTL or longer, then it must refresh the information. The shorter the TTL, the greater the frequency of Route 53 lookups and the greater the cost of using the service. In practice, these costs are negligible until you get to millions of hits, and generally the advantages of shorter TTLs overwhelm the disadvantages at this scale because of the speed with which you can make and fix changes to the way global traffic flows.
# Route 53 uses information about latency and availability from different parts of the world. It can therefore by used for dynamic and responsive IP addressing.
#* Route 53 has edge locations around the world. It determines availability and latency from each of these edge locations to each of the Amazon Web Services regions.
#* In addition, Route 53 runs each health check independently from each of the edge locations. You can view, for each health check, the history of recent health check activity, including both the health checker IP, the IP that the health check resolved to, and whether the health check was successful.
#* When a client does a lookup for a domain or subdomain in Route 53, it combines three pieces of information: (a) the client's IP address, (b) the most recent availability, latency, and health check information, and (c) the record sets and routing policies configured, to respond. Since the health check frequency is 10-30 seconds (depending on the setting) and the minimum TTL is 60 seconds, the minimum time for health check-based changes to propagate is 90-150 seconds, and the minimum time for other changes to propagate is 60 seconds.
# Traffic does not flow through Route 53, so it does not track the actual traffic.
#* Route 53 is only used by clients to look up IP addresses. The actual requests are not routed through Route 53.
#* Even for IP address lookup, not all clients touch Route 53 directly. There is caching at the level of individual browsers: a browser will cache the IP addresses locally for the duration of the TTL. There may also be caching at an intermediate level. For instance, if two different users using the same ISP in the same region look up the same address within a time difference of each other that is less than the TTL, the second user may get the address cached by the ISP's DNS resolver from the first user's request, rather than going all the way to Route 53, the authoritative DNS server.
#* Therefore, the count of requests to Route 53 does not provide a good estimate of actual traffic to the IP addresses looked up.
# Route 53 has a number of competitors and can be used with non-AWS-hosted architecture. Conversely, its competitors can be hosted with AWS-hosted architecture.
#* The biggest competitors to Route 53 include UltraDNS, Dyn, Cotendo, easyDNS, and DNS Made Easy. Route 53 has approximately comparable availability as competitors but slightly faster propagation latency and slightly lower cost.<ref>[http://blog.cloudharmony.com/2012/08/comparison-and-analysis-of-managed-dns.html Comparison and Analysis of Managed DNS Providers]</ref> With that said, Amazon.com itself does not use Route 53, which might be reason to be a little skeptical about its reliability for very-high-end deployments.<ref>[http://www.networkworld.com/article/2846234/cloud-computing/amazon-doesn-t-eat-its-own-dns-dogfood.html Amazon doesn’t eat its own DNS dogfood]</ref>
#* Route 53 as well as its competitors can be used for servers hosted on Amazon infrastructure (i.e., EC2) as well as for servers hosted elsewhere.
#* Route 53 has better hooks into EC2 (for instance, it can point to ELBs and evaluate their health quickly) and so makes particular sense to use when dealing with EC2. It also has good programmatic access and health checks.

=== Understanding the key similarities and differences between Route 53 and a load balancer ===

# Route 53 can ''prima facie'' be used to do something like load balancing.
#* For instance, if you want to balance incoming traffic across three servers, you can set a Route 53 A record with the IP addresses of all the servers. You can also set up multiple Route 53 A records with different weights, using a weighted routing policy (discussed later on this page).
#* Conversely, you can use a load balancer to receive incoming traffic and then use that load balancer to forward the traffic to the different servers.
# Since Route 53 does not include any central point of traffic flow, there are things it can do that load balancers cannot do.
#* Since traffic does not actually go through any central point, Route 53 can be used to redistribute traffic across regions without adding round-trip time to latency. With a load balancer, the round-trip time between the load balancer and the server that finally processes the request gets added to the end-user's latency. For instance, if we want to make sure that people in Europe get served by servers in Europe while people in East Asia get served by servers in East Asia (for minimal latency) routing traffic through a load balancer defeats the purpose because of the added round-trip time. However, we can use Route 53 records for this purpose without adding to latency, because the Route 53 records are resolved locally without making a trip to a central server. Moreover, due to caching (up to the TTL) of the lookups, even that local resolution has to be done only once a minute.
#* Route 53 is also correspondingly more robust to downtime, because it has a large number of edge locations that respond to requests, and has been designed based on the principle of constant work to avoid cascading failure.
#* Route 53-based routing has the advantage over Amazon's Elastic Load Balancers (ELBs) in that it can scale very quickly to large loads, whereas ELBs cannot handle very rapid and large variations in load quickly enough. Note that ELB is good enough for most use cases, but, for instance, logging company Loggly has found that Route 53 served its use case better. Note that Loggly is unusual relative to most web or API services that have a more steady or predictable load. Its reference class is "emergency management" which combines unpredictability with very quick changes in load at some times.<ref name=loggly>[https://www.loggly.com/blog/why-aws-route-53-over-elastic-load-balancing/ https://www.loggly.com/blog/why-aws-route-53-over-elastic-load-balancing/]</ref>
# Since Route 53 does not include any central point of traffic flow, it cannot do some of the things that load balancers can do.
#* Route 53 cannot be used to get a bird's eye view of the total traffic.
#* Route 53 is not good at distributing traffic equally across servers. This is because although it allows for a round robin IP lookup strategy, this is only for IP lookups and _not_ for the actual requests. Therefore, if the distribution of request sources is not totally uniform, then the distribution of traffic can also be corresponding non-uniform. This is particularly important if you are offering an API service for a small number of clients with high load per client.
#* Route 53 cannot distribute traffic ''equitably'' the way load balancers can. For instance, Amazon's Elastic Load Balancer uses the leastconns algorithm: it forwards a request to the server with the least number of outstanding requests. This helps reduce traffic load on slower or more unresponsive servers. This is not possible in Route 53 since traffic does not even flow through it, and it has no awareness of the response times of individual servers.
#* Servers cannot be added to or removed from Route 53 as quickly as they can with a load balancer. Route 53 also cannot be integrated directly into the autoscaling that AWS offers, though it is possible to write scripts that both create new servers and add records to them using the Route 53 API based on the traffic load currently being experienced, as logging company Loggly has done.
# With all these caveats, it is important to note that Route 53 and load balancing are complements, not competitors.
#* Load balancing is best suited for distributing traffic equitably, and maintaining high availability, ''within'' a region.
#* Route 53 is best suited for guaranteeing availability across regions, minimizing latency, and handling cross-region redundancy and failover.

=== Understanding the similarities and differences between Route 53 and a CDN (such as CloudFront) ===

# Route 53 and Content Delivery Networks (CDN) share the feature that they are massively distributed, with edge locations around the world.
#* In fact, Route 53 and Amazon CloudFront (Amazon's CDN-like service) service share edge locations.
# Route 53 serves IP addresses, whereas a CDN serves content.
#* The goal of a CDN is to directly respond to a query for a (typically static) resource by serving that resource, without hitting the original server or file system that stores the resource. The CDN refreshes the resource from the source (server or filesystem) either periodically or when the resource is explicitly purged.
#* The goal of Route 53 and other managed DNS services is to respond to DNS lookup queries only and not to serve actual content.
#* You can use a CDN to offer low round-trip times around the world to all users (bounded by the round-trip time to the closest edge location), but Route 53 does not do this.
# There is an interesting way of using CDNs as central points of traffic flow, namely, to accelerate the three-way handshake used to establish the initial connection. Route 53 does not offer this.<ref>[http://chimera.labs.oreilly.com/books/1230000000545/ch04.html#TLS_EARLY_TERMINATION Chapter 4. Transport Layer Security (TLS)]</ref>

=== Understanding the key Route 53 concepts: hosted zone, health check, and record set ===

# A public hosted zone is a container for all the record sets associated with a web domain and its subdomains.<ref>[http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/AboutHZWorkingWith.html Working with Public Hosted Zones]</ref><ref>[http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/CreatingHostedZone.html Creating a Public Hosted Zone]</ref>
#* Each public hosted zone has one NS (Name Server) record that specifies the four Amazon nameservers to use to resolve the domain and its subdomains. This set of four nameservers is called a delegation set. To migrate the DNS records to Amazon Route 53, you need to update the list of four nameservers with the registrar (where you have registered the domain) to this set of four nameservers. This list can take 24-48 hours to update globally.
#* Each public hosted zone also has one SOA (Start of Authority) record that provides authoritative information about the domain, including the primary nameserver, the email of the domain administrator, the domain serial number, and timers related to refreshing the zone.
#* The delegation set is generally different for different public hosted zones. However, it is possible to use the Route 53 API to have the same delegation set be used for different public hosted zones. This helps make it easy to migrate hosting for a large number of websites since many registrars allow users to specify a default set of nameservers to use across all their domains.
# The individual items in each hosted zone are called record sets. These correspond to DNS records, but with some additional settings.
#* Each record set has a set of addresses that the subdomain may resolve to. These addresses could be IP addresses (that may or may not be EC2 instances) or DNS names (such as for an EC2 ELB, S3 bucket configured as a static site, or CloudFront distribution). Note that when we use DNS names, the DNS name in turn may resolve to one or more IP addresses. For instance, an EC2 ELB will generally resolve to multiple IP addresses, with the number of IP addresses depending on the number of availability zones it is operational in, as well as the traffic load it is handling.
#* Each record set is associated with the domain or a subdomain of the domain associated with the hosted zone, and plays a role in resolving that domain. In general, it is possible (and crucial) to have multiple record sets (each of which may in turn have multiple records) for a single subdomain.
#* Each record set has a record type. The record types are a subset of the types of DNS records. The most important record types for ordinary use cases are Address records (A records) and Canonical Name records (CNAME records). The CNAME makes sense when you are simply rewriting one subdomain to another. The A record is much more versatile.
#* When using a record that points directly to the IP address of an EC2 instance, make sure that the IP address is an elastic IP so that it survives the termination of the instance and can be reattached to a new instance.<ref>[http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-to-ec2-instance.html Routing Queries to an Amazon EC2 Instance]</ref>
#* When using an A or CNAME record for an Elastic Load Balancer, CloudFront distribution, S3 bucket configured as a static site, or Route 53 record, it is possible to set it as an Alias. An Alias record simply remaps the subdomain to the DNS name it is aliased to, and therefore changes to the latter are automatically picked by the former. This allows A records to have some of the benefits of CNAME records while still allowing for multiple records per subdomain. It also allows for deeper integration with the underlying resources, including a direct evaluation of the target health without setting up separate health checks. The idea of the alias record was introduced by DNSimple (not affiliated with Amazon Route 53).<ref>[http://scripting.com/stories/2011/11/13/dnsimplesNewAliasFeature.html dnsimple's new ALIAS feature]</ref><ref>[http://blog.dnsimple.com/2011/11/introducing-alias-record/ Introducing the ALIAS Record - Naked Domain Aliasing that Works!]</ref> Amazon's implementation differs somewhat from DNSimple's.<ref>[http://serverfault.duapp.com/questions/605087/route-53-naked-root-domain-alias-record Route 53 Naked/Root Domain Alias Record]</ref> Amazon offers a guide on the use of Alias versus Non-Alias Resource Record Sets.<ref>[http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-choosing-alias-non-alias.html Choosing Between Alias and Non-Alias Resource Record Sets]</ref>
#* In the case of multiple record sets for a given subdomain, and the full picture of how DNS lookups for that subdomain will resolve depends on all the record sets and their interaction.<ref>[http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html Choosing a Routing Policy]</ref>
# Some types of record sets support health checks and evaluation of target health.
#* For any record type (alias or not, and regardless of record type) with a policy other than "Simple" (the record types are discussed in the next part) you can associate a health check. This can ping a specific endpoint (with a port you can specify) using the HTTP protocol (other protocols are not supported) and look for a specific search string in the response. The request interval can be set to either 10 seconds or 30 seconds. The timeout limit for response, the length of initial segment of response that will be matched against the search string, and the fraction of health checks that need to pass for the endpoint to be considered healthy are all controlled by Amazon and not user-configurable.
#* The "Evaluate Target Health" option is available for alias records (CNAME or A records) regardless of the policy. Since this option is offered only for specific Amazon resources, it can benefit from deep integration with the underlying resources. For instance, in the special case of Alias records (CNAME or A records) that point to Amazon EC2 ELBs, the target health evaluation passes if and only if the ELB has at least one instance that is registered and in service.<ref>[https://aws.amazon.com/blogs/aws/amazon-route-53-elb-integration-dns-failover/ Amazon Route 53 Adds ELB Integration for DNS Failover]</ref> This is a special behind-the-scenes deep integration between the two AWS services (Route 53 and ELB).

=== Understanding routing policies and selecting an appropriate policy ===

# The simplest routing policy is a "simple" routing policy. This is for cases where there is only one record set associated with the subdomain. A simple routing policy can include multiple IP or DNS addresses, and will resolve to each of them an equal fraction of the time. Specifically, it follows a round robin strategy. Simple routing policies pair well with CNAME records. As always, use an Alias record if pointing to an EC2 DNS address such as an Elastic Load Balancer, and evaluate the target health.
# Another commonly used routing policy is a "weighted" routing policy. Here, each record set associated with a subdomain gets a weight. Within the record set, all individual IP addresses are resolved using a round robin strategy. Across the record sets, the probability of a given record set being used is the ratio of the weight of the record set to the sum of weights of all record sets for the subdomain. For instance, if there are record sets of weights 3, 2, 2, and 1 respectively for a subdomain, they are selected with probabilities of 3/8, 2/8, 2/8, and 1/8 respectively.
#* Weighted routing policies make sense only in case of multiple record sets, all using the weighted routing policy.
#* Typically, for a weighted routing policy, we only specify one IP address or DNS A record per record set, and therefore create as many record sets as the number of IP addresses or DNS A records.
#* Note that the numerical weight associated with a record set in a weighted routing policy does not give a full picture of the probability of that record set being used: we also need to know the denominator (the sum of weights across all record sets). In particular, if we add a new record set, the probability of resolving to each of the other record sets goes down in the same proportion. Similarly, if the weight on one of the record sets is altered, this affects the probability for all the other record sets.
# The "latency" routing policy (known as latency-based routing, or LBR) is one of the more sophisticated routing policies. Each latency record specifies an Amazon Web Services region.
#* The latency-based router, when asked to resolve the subdomain, looks at its periodically refreshed table of the latency between the following areas: its edge location closest to the IP address doing the lookup, and the Amazon Web Services region specified in the record set.
#* Note that it is not logically entailed that the records in the record set are located in the AWS region specified for latency-based routing. In fact, your records may not be on AWS infrastructure at all! If they are on AWS infrastructure, it makes sense to use the AWS region they are in. Otherwise, it makes sense to use the closest AWS region, to offer the best proxy for latency to those records.<ref name=viki/>
#* Similar to the case of weighted records, latency-based record sets make sense only when there is more than one of them. In this case, the latency for each record set is calculated as explained above (by a table lookup of latency between the closest edge location to the requester and the AWS region specified in the record set). Then, the record set with the lowest reported latency is returned.
#* Note, in particular, that this estimate of latency may be very different from the actual latency of queries, for two reasons: it uses latency from edge locations to the AWS region rather than from the actual client to the actual server, and second, it ignores the processing time on the servers itself, which could vary between regions.
#* In particular, unlike the leastconns load balancer used by Amazon's ELBs, that adaptively redistributes traffic based on latency differences, Route 53 does not take into account any information about actual query latency. We might ideally imagine that if one region is slower than another, the other region will pick up a larger share of traffic from geographical locations somewhere in the middle of the two. Latency-based routing does ''not'' do this.
#* The latency-based routing algorithm has been known to fail, in that it sometimes routes traffic to an incorrect location.<ref name=viki>[http://openmymind.net/How-Good-Is-Amazons-Route-53-Latency-Based-Routing/ How Good Is Amazon's Route 53 Latency Based Routing?]</ref> Therefore, if latency is truly important to you and you have a small set of customers who heavily use your API, it's better to give them subdomains that directly resolve to particular regions rather than use LBR hoping that they will be routed correctly.
# The "geolocation" routing policy is similar to latency-based routing, but allows explicit specification of what geographical locations should get mapped to what record sets.
# AWS Route 53 offers both active and passive failover based on health checks and direct evaluation of target health, all of which operate on the principle of constant work to avoid cascading failure.<ref>[http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html How Amazon Route 53 Determines Whether an Endpoint Is Healthy]</ref><ref>[http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-simple-configs.html How Health Checks Work in Simple Amazon Route 53 Configurations]</ref>
#* If you associate health checks with your Route 53 record sets, then a particular record set is taken out of commission after failing three successive health checks (the number of failures may be configurable). Similarly, if you are evaluating target health of the ELB, a record set is taken out of commission once the target proves unhealthy. The record sets come back live once the health check or target health return to normal. The maximum time for the effect to be global is 150 seconds: 3 30-second failed checks, plus 60-second TTL (note that the TTL is configurable and if you set it to longer then it will take more time for the change to propagate).
#* For weighted routing policies, this means that the weights on the still-healthy record sets increase proportionately.
#* For latency-based routing policies, this means that if a record set goes down entirely, all the traffic that would have been routed there is instead routed to the next-lowest-latency region for that particular part of traffic. Therefore, the load for the other regions will not increase in the same proportion, but rather it will increase based on their proximity to the traffic that was servedby the now-down region. This can lead to a cascading failure. For instance, say you have three regions: us-west-1, us-east-1, and eu-west-1, with one record set for each, and you have configured capacity to handle typical traffic loads for each region. Now, suppose us-east-1 goes down. In this case, almost all the traffic for us-east-1 will go to us-west-1, the closest region for most of the traffic that would go to us-east-1. This could be a significant traffic increase for us-west-1, and the increased load could cause the region to collapse. Now, ''all'' global traffic hits eu-west-1, which might cause that region to collapse. The upshot is that passive failover can actually cause a global collapse without careful design. The problem is more acute than with weighted routing policies because of how a lot of the rerouted traffic goes to one region.
#* It is also possible to have record sets explicitly designated as failover. These record sets are used only if ''all'' the other record sets go out of commission. We can use these to serve static backups.
# It can be hard to switch record type, aliasing, and routing policies in the Route 53 console.
#* For instance, there are constraints on the record sets for a particular subdomain: we cannot mix weighted and latency-based records, and we cannot have more than one simple record.
#* One way out of this challenge is to start with a tree structure of records to begin with, allowing for the creation of a new branch of the tree. Amazon offers guides on complex DNS configuration.<ref>[http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-complex-configs.html How Health Checks Work in Complex Amazon Route 53 Configurations]</ref>
#* Using the Route 53 API gives more flexibility with making changes than using the console since more complex changes can be made more quickly, minimizing downtime during tricky changes between configurations.

=== Preparing to make Route 53 part of a high availability infrastructure ===

# Understand that Route 53 is a key part of a multi-region configuration.
#* Invest at least a few hours in making sure that your Route 53 policies are set reasonably.
#* Investigate the use of traffic policies and traffic flow that allow you to store complex configurations. In the long run, clicking around in the console to modify policies is not a good idea for a key ingredient to your availability.
#* Investigate incorporating updates to the Route 53 API in your deployment scripts (such as Ansible or Chef scripts).
# As mentioned earlier, if latency is particularly important for a customer, or if for some other reason you want a particular customer to only hit your API endpoint in a particular region, it is better to give them a subdomain for which you have configured records only for that region, rather than rely on latency-based or geolocation-based routing. These don't usually fail, but when they do, you are helpless.
# Familiarize yourself with shell commands for better debugging.
#* whois can look up authoritative registration information for domains.
#* nslookup can be used to get information about the nameservers.<ref>[http://www.tecmint.com/8-linux-nslookup-commands-to-troubleshoot-dns-domain-name-server/ 8 Linux Nslookup Commands to Troubleshoot DNS (Domain Name Server)]</ref>
#* dig ('''the most useful command for Route 53 debugging''') can find the IP addresses associated with a given subdomain, and you can verify that the results returned conform with your routing policy. It also prints the remaining TTL. When you issue the first command, this should be your full TTL. Subsequent invocations within the TTL should show the remaining TTL. For instance, if your TTL is 60 seconds, then running dig after 15 seconds should show a TTL of 45 seconds. If DNS name A has latency-based alias records pointing to DNS name B and DNS name C, you can dig all three names, and then see if the IP addresses that A resolves to matches the IP addresses that B and C resolve to. You can also specify a +trace option to dig to print the trace.<ref>[http://www.cyberciti.biz/faq/unix-linux-dns-lookup-command/ Linux / UNIX: DNS Lookup Command]</ref>
#* traceroute is also useful to get clearer information on how the resolution occurred.
#* ping can be used to query the DNS address and get estimates of the round-trip time.
#* curl or wget can be used to make a HTTP request and get a response.
#* You may run these shell commands from your own machine or by logging in to remote servers in various locations.
# Identify some online places to resolve DNS addresses from multiple locations and report the IP addresses. Some examples are whatsmydns.net<ref>[https://www.whatsmydns.net/ whatsmydns.net: Global DNS Propagation Checker]</ref> and check-host.net.<ref>[http://check-host.net/check-dns Check Host]</ref>

== Related wikiHows ==
* [[Optimize Your Amazon EC2 Costs|How to Optimize Your Amazon EC2 Costs]]
* [[Optimize Your Amazon S3 Costs|How to Optimize Your Amazon S3 Costs]]
* [[Use Amazon EC2 Spot Instances|How to Use Amazon EC2 Spot Instances]]
* [[Upload to Amazon S3|How to Upload to Amazon S3]]

== References ==
{{reflist}}

__PARTS__
